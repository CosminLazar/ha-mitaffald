use mitaffald::{get_containers, Container};
use rumqttc::AsyncClient;
use settings::Settings;
use std::collections::{hash_map::Entry, HashMap};

pub mod homeassistant;
pub mod mitaffald;
pub mod settings;

pub async fn sync_data(settings: Settings) -> Result<(), String> {
    let mut device = homeassistant::HADevice::default();
    let (mut client, mut connection) = AsyncClient::new(settings.mqtt.into(), 200);

    let containers_to_report = get_containers(settings.affaldvarme)
        .await?
        .into_iter()
        .fold(
            HashMap::<String, Container>::new(),
            |mut accumulator, item| {
                match accumulator.entry(item.name.clone()) {
                    Entry::Occupied(mut existing) => {
                        if existing.get().date > item.date {
                            existing.insert(item);
                        }
                    }
                    Entry::Vacant(v) => {
                        v.insert(item);
                    }
                }

                accumulator
            },
        )
        .into_values();

    let has_errors = {
        let mut has_errors = false;
        for container in containers_to_report {
            let report_result = device.report(container, &mut client).await;

            has_errors = has_errors || report_result.is_err();
        }
        has_errors
    };

    //calling disconnect() causes an error in the connection iterator
    if let Err(x) = client.disconnect().await {
        return Err(x.to_string());
    }

    //iterate the connection untill we hit the error generated by disconnect()
    loop {
        let notification = connection.poll().await;
        if notification.is_err() {
            break;
        }
    }

    if has_errors {
        Err("Failed to report all containers".into())
    } else {
        Ok(())
    }
}
